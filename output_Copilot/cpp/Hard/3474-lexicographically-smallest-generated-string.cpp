/*
 You are given two strings, str1 and str2, of lengths n and m, respectively.
 A string word of length n + m - 1 is defined to be generated by str1 and str2 if it satisfies the following conditions for each index 0 <= i <= n - 1:
 If str1[i] == 'T', the substring of word with size m starting at index i is equal to str2, i.e., word[i..(i + m - 1)] == str2.
 If str1[i] == 'F', the substring of word with size m starting at index i is not equal to str2, i.e., word[i..(i + m - 1)] != str2.
 Return the lexicographically smallest possible string that can be generated by str1 and str2. If no string can be generated, return an empty string "".
 Example 1:
 Input: str1 = "TFTF", str2 = "ab"
 Output: "ababa"
 Explanation:
 The table below represents the string "ababa"
 Index
 T/F
 Substring of length m
 0
 'T'
 "ab"
 1
 'F'
 "ba"
 2
 'T'
 "ab"
 3
 'F'
 "ba"
 The strings "ababa" and "ababb" can be generated by str1 and str2.
 Return "ababa" since it is the lexicographically smaller string.
 Example 2:
 Input: str1 = "TFTF", str2 = "abc"
 Output: ""
 Explanation:
 No string that satisfies the conditions can be generated.
 Example 3:
 Input: str1 = "F", str2 = "d"
 Output: "a"
 Constraints:
 1 <= n == str1.length <= 104
 1 <= m == str2.length <= 500
 str1 consists only of 'T' or 'F'.
 str2 consists only of lowercase English characters.
*/

class Solution {
public:
    string generateString(string str1, string str2) {
        int n = str1.size();
        int m = str2.size();
        string result(n + m - 1, 'a'); // Start with the smallest lexicographical character

        for (int i = 0; i < n; ++i) {
            if (str1[i] == 'T') {
                // If str1[i] is 'T', the substring must match str2
                for (int j = 0; j < m; ++j) {
                    if (i + j < result.size()) {
                        result[i + j] = str2[j];
                    }
                }
            } else if (str1[i] == 'F') {
                // If str1[i] is 'F', the substring must not match str2
                for (int j = 0; j < m; ++j) {
                    if (i + j < result.size() && result[i + j] == str2[j]) {
                        // Change to a different character
                        result[i + j] = (result[i + j] == 'z') ? 'y' : 'z';
                    }
                }
            }
        }

        // Check if the generated string is valid
        for (int i = 0; i < n; ++i) {
            string sub = result.substr(i, m);
            if ((str1[i] == 'T' && sub != str2) || (str1[i] == 'F' && sub == str2)) {
                return ""; // Invalid string
            }
        }

        return result;
        
    }
};